TITLE:: ServerRecover
summary:: Strategies for servers to recover when booting shows port conflicts
categories:: Control
related:: Classes/Server


DESCRIPTION::

When trying to boot a server, the server may find that there is already a process
using the desired port number. This can have several reasons, and several strategies.

* It may be a server zombie from a language crash.
One can recover by hijacking that server, or reboot it.

* It may be an scsynth or supernova program run by another application.
One can recover by switching to a different port number.

* In more complex network music settings, one can add further custom
strategies to ServerRecover.

Code examples:

code::

//
// find all server processes on this machine:
ServerRecover.findProcesses;
// for example:
-> [ ( 'username': adc, 'pid': 36998, 'port': 57110 ) ]

// find the pid for the port I want to use
ServerRecover.pidForPort(57110);
// for example:
-> 36998


// first, test regular boot and accidental quit:
// kill all servers first
unixCmd("killall scsynth supernova");
// server address port is free, could boot now
s.addr.portIsFree;
// regular boot, should work fine
s.boot;
// now simulate server crash with unixCmd, not Server.killAll;
unixCmd("killall scsynth supernova");
s.serverRunning;


// now demonstrate the zombie problem:

unixCmd("killall scsynth supernova");
// start an scsynth instance by hand to simulate a zombie:
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
// now server port is used, and regular boot would fail ...
s.addr.portIsFree;

// recover option 1 is 'failAndAsk', which informs about options 2-4:
ServerRecover.default.cs;
s.boot;
//////////// posts : //////////////
// ServerRecover 'failAndAsk' for server 'localhost' - options:
// There is already a server using port 57110. You can
// * force-reboot the server:
ServerRecover.default = 'reboot'; s.boot;
// * or find a different port and boot:
ServerRecover.default = 'useFreePort;' s.boot;
// * or hijack the existing server:
ServerRecover.default = 'hijack;' s.boot;
//////////////////////////////////


// recover option 2 is 'hijack' - assumes it is a zombie and reuses that,
ServerRecover.default = \hijack;
// for annoyance, add a dangling note to the zombie
s.addr.sendMsg("/s_new", \default, 1234);
// hijacking sends a freeAll command
s.boot;
s.serverRunning; // it knows it is running now
s.pidRunning;    // and has been told its hijacked pid

unixCmd("killall scsynth supernova");
s.serverRunning; // knows it is dead
s.pid;  		// and no pid anymore


// recover option 3 is 'reboot' - this is safer:
// kills the old scsynth, then boots the server.
// create zombie first
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
ServerRecover.default = \reboot;
s.boot;

////////////// \reboot runs and posts TWICE - why? /////////////


// option 3 is 'useFreePort' - this is more polite:
// other programs on this machine may use port 57110,
// for instance to run scsynth instances at the default port.
// 'useFreePort'  finds a free port number, and boots server with that port.
// Switching to a free port number by hand would also work.
unixCmd("killall scsynth supernova");
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
ServerRecover.default = \useFreePort;
s.boot;

// test case for multi-servers:

(
// make sure there are no scsynth processed around
unixCmd("killall scsynth supernova");
// Start three servers, as if by other programs, or zombies
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
x = (Server.program + s.options.asOptionsString(57109)).unixCmd;
x = (Server.program + s.options.asOptionsString(57108)).unixCmd;
)

ServerRecover.default = \useFreePort;
s.boot;
s.addr; // moved port out of the way.


::

CLASSMETHODS::

METHOD:: findProcesses
get info for all running scsynth (or supernova) processes.

METHOD:: pidForPort
get the pid for the given port number, or nil if none found.

METHOD:: bootStrategies
a dictionary of all the strategies

METHOD:: at
argument:: key
get strategy at key, or default.

